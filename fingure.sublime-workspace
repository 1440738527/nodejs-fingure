{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"sec",
				"security_date"
			],
			[
				"me",
				"messageBuffer"
			],
			[
				"fin",
				"fingureAddressIndex"
			],
			[
				"sendB",
				"sendBufferLength"
			],
			[
				"sendCm",
				"sendCmdAndParams"
			],
			[
				"sendBu",
				"sendBufferLength"
			],
			[
				"messageBu",
				"messageBufferLength"
			],
			[
				"de",
				"define"
			],
			[
				"ucharM",
				"ucharMainBuffer"
			],
			[
				"ucharBu",
				"ucharBuffer"
			],
			[
				"ucha",
				"ucharBuffer"
			],
			[
				"message",
				"messageBuffer"
			],
			[
				"mesag",
				"messageReadble"
			],
			[
				"uartS",
				"uartSendBuffer"
			],
			[
				"receiveBu",
				"receiveBufferLength"
			],
			[
				"receive",
				"receivePackageLength"
			],
			[
				"ACTION_GETfIN",
				"ACTION_GET_FINGURE_ADDRESS_LIST0"
			],
			[
				"uint",
				"uintTemp"
			],
			[
				"uartSen",
				"uartSendByte"
			],
			[
				"uin",
				"uintTemp"
			],
			[
				"uchar",
				"ucharTemp"
			],
			[
				"ACTION_",
				"ACTION_GET_IMAGE_FOR_CHECK"
			],
			[
				"uchaR",
				"ucharTemp"
			]
		]
	},
	"buffers":
	[
		{
			"file": "mcu-plc-fingure/mpf.c",
			"settings":
			{
				"buffer_size": 18313,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "mcu-plc-fingure/led.c",
			"settings":
			{
				"buffer_size": 736,
				"encoding": "UTF-8",
				"line_ending": "Windows",
				"name": "s"
			}
		},
		{
			"file": "/D/workspace2/git/sytec/company/ChangZhouYouRui/20170322mcu/double_encrypt_12AM.c",
			"settings":
			{
				"buffer_size": 34126,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "mcu-plc-fingure/fingure.c",
			"settings":
			{
				"buffer_size": 3791,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "mcu-plc/mcu-plc.c",
			"settings":
			{
				"buffer_size": 3634,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "/D/workspace/Qt/SimensKeyboard/mainwindow.cpp",
			"settings":
			{
				"buffer_size": 1149,
				"encoding": "UTF-8 with BOM",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/* 姜堰市世祥加密程序 2008-01-10 */\n/* 随机密码加密*/\n/* 此程序是在sycg(sycg1230)的基础上修改的 */\n/* 24C08地址分配：*/\n/* 0区存放128个随机码，以保证每次随机码不相同，超过128则从0重新存放*/\n/* 1区00-04存放解密后的日期 */\n/* 1区05存放初次进入该解密阶段 */\n/* 1区06存放0区的随机码地址*/\n/* 1区07-08存放解密成功的解密密码，永久解密密码60815，阶段解密密码20926，解密结束0*/\n/* 1区10-11存放识别密码 */\n#include<reg51.h>\n#include<intrins.h>\n#include<stdlib.h>\n#include<absacc.h>\n#include<math.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Lock    0x0a\n#define Unlock  0x0b\n#define Enter   0x0c\n#define Cancel  0x0d\n#define Serial_num 0x0e\n#define Secret_code 0x0f\n//#define Rest 0xff\n\n//#define LS244H XBYTE[0xbfff]   /* 刀库 */\n//#define LS244L XBYTE[0xdfff]   /* 主轴 */\n//#define LS377  XBYTE[0xefff]   /* 显示位选 */\n//#define COM8255 XBYTE[0x7fff]  /* 8255控制口 */\n// #define PA8255  XBYTE[0x7cff]  /* 8255A口 */\n//#define PB8255  XBYTE[0x7dff]  /* 8255B口 */\n//#define PC8255  XBYTE[0x7eff]  /* 8255C口 */\n\nsbit wp24c08 = P3 ^ 2;\nsbit sclk = P3 ^ 3;\nsbit sda = P3 ^ 4;\nsbit rst1302 = P3 ^ 5;\n//sbit P1_7=P1^7;\n\n#define devicead_ws 0xa0\n#define devicead_rs 0xa1      /* page0 security code */\n#define devicead_wd 0xa2\n#define devicead_rd 0xa3      /* page1 securiyy day */\n#define devicead_wm 0xa4\n#define devicead_rm 0xa5      /* page2 securiyy date */\n\n//uchar  sflag[16]={0};\n\nuchar flag_key;//=sflag[0];     /* 键盘标志 */\nuchar flag_pass;//=sflag[1];    /* 永久使用标志 */\nuchar flag_5m;//=sflag[2];      /* 5分钟标志 */\nuchar flag_ok;//=sflag[2];      /* 正确密码标志 */\nuchar flag_series;//=sflag[3];  /* 串口写调试密码标志*/\nuchar flag_series_unlock;//=sflag[4];  /* 串口解密标志*/\nuchar flag_interrupt_dis;//=sflag[5];  /* 中断滚动显示，显示解锁、加密 */\nuchar flag_all_unlock;//=sflag[6];     /* 完全解密标志 */\nuchar flag_test;//=sflag[7];           /* 调试键标志 */\nuchar flag_unlock;//=sflag[8];         /* 解密标志 */\nuchar flag_over;//=sflag[9];           /* 计算加密时间时的溢出标志 */\nuchar flag_shift;//=sflag[10];          /* shift键标志 */\nuchar flag_flash;//=sflag[11];          /* 闪烁显示标志 */\nuchar flag_jiami;//=sflag[12];          /* 已按加密部分数字键或功能键 */\nuchar flag_digital;//=sflag[13];        /* 数字键标志 */\nuchar flag_error;//=sflag[14];          /* 产生随机码标志 */\nuchar flag_warn_yymmdd;//=sflag[15];    /* 产生计算加密日期标志 */\n\nsbit tmp_shift_key = P0 ^ 6;\nsbit tmp_lock = P0 ^ 7;\n\n\nuchar data key_num;\nuint data counter_5m;\nuchar data term;     /*　保存有效密码阶段，以防误动作时读加密时间有误 */\nuchar data series_string[6];\nuchar data digital_string[6];\nuchar data syts_string[6];  /* 用于显示剩余天数时备用显示随机码 2004/04/10增加*/\nuchar data valid_day[2];  /*显示天数*/\nuchar data flash_valid_day; /*闪烁显示天数的显示频率*/\nuchar data yun;\n/* 显示------ */\n//uchar code display0[13]={0xa4,0x90,0x01,0x91,0x01,\n// 0x92,0x01,0x93,0x01,0x94,0x01,0x95,0x01};\n/* 显示888888 */\n// uchar code display1[13]={0xa4,0x80,0x08,0x81,0x08,\n// 0x82,0x08,0x83,0x08,0x84,0x08,0x85,0x08};\n/* 显示字符 0、1、2、3、4、5、6、7、8、9、- 、d 、空 ,P,H,E*/\nuchar code display_code[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d,\n                             0x7d, 0x07, 0x7f, 0x6f, 0x40, 0x5e, 0x00, 0x73, 0x76, 0x79\n                            };\n//uchar code display_code[]={0x00,0x01,0x02,0x03,0x04,\n//0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0f,0x0c,0x0d,0x0e};\n/* 位选控制字 0位、1位、2位、3位、4位、5位 */\nuchar code display_cs[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20};\nuchar code monthp[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nuchar code monthy[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n\nvoid delay_xms(uchar j)   /*延时 j*1ms*/\n{\n    uchar data i;\n    for(; j > 0; j--)\n    {\n        for(i = 0; i < 125; i++)\n        {\n            ;\n        }\n    }\n}\n\nvoid start_ic(void)    /*start 24c08*/\n{\n    wp24c08 = 0;\n    sclk = 0;\n    _nop_();\n    _nop_();\n    sda = 1;\n    _nop_();\n    _nop_();\n    sclk = 1;\n    _nop_();\n    _nop_();\n    sda = 0;\n    _nop_();\n    _nop_();\n    sclk = 0;\n    _nop_();\n}\n\nvoid stop_ic(void)    /*stop 24c08*/\n{\n    sclk = 0;\n    _nop_();\n    _nop_();\n    sda = 0;\n    _nop_();\n    _nop_();\n    sclk = 1;\n    _nop_();\n    _nop_();\n    sda = 1;\n    _nop_();\n    _nop_();\n    sclk = 0;\n    _nop_();\n    _nop_();\n    sda = 0;\n    wp24c08 = 1;\n}\n\nvoid write_byte(uchar wr_byte)    /*write 1byte to 24c08*/\n{\n    uchar data temp, bitcounter = 8;\n    sclk = 0;\n    _nop_();\n    _nop_();\n    do\n    {\n        temp = wr_byte;\n        temp = temp & 0x80;\n        if(temp == 0x80)\n            sda = 1;\n        else\n            sda = 0;\n        _nop_();\n        sclk = 1;\n        temp = wr_byte << 1;\n        wr_byte = temp;\n        _nop_();\n        _nop_();\n        sclk = 0;\n        _nop_();\n        _nop_();\n        bitcounter--;\n    }\n    while(bitcounter);\n    sda = 1;\n    sclk = 1;\n    while(sda);\n    sclk = 0;\n    _nop_();\n}\n\nuchar read_byte(void)     /*read 1byte from 24c08*/\n{\n    uchar data temp = 0;\n    uchar data temp1 = 0;\n    uchar data bitcounter = 8;\n    sda = 1;\n    do\n    {\n        if(sda)\n            temp = temp | 0x01;\n        else\n            temp = temp & 0xfe;\n        if(bitcounter - 1)\n        {\n            temp1 = temp << 1;\n            temp = temp1;\n        }\n        bitcounter--;\n        sclk = 1;\n        _nop_();\n        _nop_();\n        sclk = 0;\n        _nop_();\n        _nop_();\n    }\n    while(bitcounter);\n    return(temp);\n}\n/*写字符*/\nvoid write_chr_to_eeprom(uchar page, uchar byte_address, uchar num)\n{\n    start_ic();\n    write_byte(page);\n    write_byte(byte_address);\n    write_byte(num);\n    stop_ic();\n    delay_xms(10);\n}\n/*读字符*/\nuchar read_chr_from_eeprom(uchar page, uchar byte_address)\n{\n    uchar data a;\n    start_ic();\n    write_byte(page);\n    write_byte(byte_address);\n    start_ic();\n    write_byte(page + 1);\n    a = read_byte();\n    stop_ic();\n    return(a);\n}\n\n/* 写浮点数 */\nvoid write_flt_to_eeprom(uchar device_address, uchar address, unsigned long ft)\n{\n    uchar data i, *px;\n    uchar data kb[4];\n    void *pf;\n\n    px = kb;\n    pf = &ft;\n    for(i = 0; i < 4; i++)\n        *(px + i) = *((char *)pf + i);\n\n    for(i = 0; i < 4; i++)\n    {\n        start_ic();\n        write_byte(device_address);\n        write_byte(address + i);\n        write_byte(*(px + i));\n        stop_ic();\n        delay_xms(10);\n    }\n}\n\n/* 读浮点数 */\nunsigned long read_flt_from_eeprom(uchar device_waddress, uchar address)\n{\n    uchar data i, *px;\n    uchar data kb[4];\n    unsigned long data ft;\n    void *pf;\n\n    px = kb;\n    pf = &ft;\n    for(i = 0; i < 4; i++)\n    {\n        start_ic();\n        write_byte(device_waddress);\n        write_byte(address + i);\n        start_ic();\n        write_byte(device_waddress + 0x01);\n        *(px + i) = read_byte();\n        stop_ic();\n    }\n    for(i = 0; i < 4; i++)\n        *((char *)pf + i) = *(px + i);\n    return(ft);\n}\n\nvoid ack_ic(void)\n{\n    sclk = 0;\n    _nop_();\n    _nop_();\n    sda = 0;\n    _nop_();\n    _nop_();\n    sclk = 1;\n    _nop_();\n    _nop_();\n    sclk = 0;\n    _nop_();\n    sda = 1;\n    _nop_();\n}\n\n/*写整数*/\nvoid write_inte_to_eeprom(uchar device_address, uchar address, uint num)\n{\n    //uchar data pp;\n    start_ic();\n    write_byte(device_address);\n    write_byte(address);\n    write_byte(num / 256);\n    write_byte(num % 256);\n    stop_ic();\n    delay_xms(10);\n    delay_xms(10);\n}\n\n/*读整数*/\nuint read_inte_from_eeprom(uchar device_waddress, uchar address)\n{\n    uchar data a;\n    uint data b;\n    start_ic();\n    write_byte(device_waddress);\n    write_byte(address);\n    start_ic();\n    write_byte(device_waddress + 1);\n    a = read_byte();\n\n    b = a * 256;\n    ack_ic();\n    a = read_byte();\n    b = b + a;\n    stop_ic();\n    return(b);\n}\n\nvoid ds1302_send_byte(uchar command, uchar num)\n{\n    uchar data temp, bitcount = 8;\n\n    wp24c08 = 1;\n    rst1302 = 0;\n    _nop_();\n    _nop_();\n    sclk = 0;\n    _nop_();\n    _nop_();\n    rst1302 = 1;\n    _nop_();\n    _nop_();\n    do\n    {\n        temp = command;\n        temp = temp & 0x01;\n        if(temp == 0x01)\n            sda = 1;\n        else\n            sda = 0;\n        _nop_();\n        _nop_();\n        sclk = 1;\n        _nop_();\n        _nop_();\n        sclk = 0;\n        temp = command >> 1;\n        command = temp;\n        bitcount--;\n        _nop_();\n    }\n    while(bitcount);\n\n    bitcount = 8;\n    do\n    {\n        temp = num;\n        temp = temp & 0x01;\n        if(temp == 0x01)\n            sda = 1;\n        else\n            sda = 0;\n        _nop_();\n        _nop_();\n        sclk = 1;\n        _nop_();\n        _nop_();\n        sclk = 0;\n        temp = num >> 1;\n        num = temp;\n        bitcount--;\n        _nop_();\n    }\n    while(bitcount);\n    _nop_();\n    rst1302 = 0;\n}\n\nuchar ds1302_receive_byte(uchar command)\n{\n    uchar data temp, rcvdat, bitcount = 8;\n\n    wp24c08 = 1;\n    rst1302 = 0;\n    _nop_();\n    _nop_();\n    sclk = 0;\n    _nop_();\n    _nop_();\n    rst1302 = 1;\n    _nop_();\n    _nop_();\n    do\n    {\n        temp = command;\n        temp = temp & 0x01;\n        if(temp == 0x01)\n            sda = 1;\n        else\n            sda = 0;\n        _nop_();\n        _nop_();\n        sclk = 1;\n        _nop_();\n        _nop_();\n        sclk = 0;\n        temp = command >> 1;\n        command = temp;\n        bitcount--;\n        _nop_();\n    }\n    while(bitcount);\n\n    bitcount = 8;\n    temp = 0;\n    rcvdat = 0;\n    do\n    {\n        if(sda)\n            temp = temp | 0x80;\n        else\n            temp = temp & 0x7f;\n        if(bitcount - 1)\n        {\n            rcvdat = temp >> 1;\n            temp = rcvdat;\n        }\n\n        bitcount--;\n        sclk = 1;\n        _nop_();\n        _nop_();\n        sclk = 0;\n        _nop_();\n        _nop_();\n    }\n    while(bitcount);\n    _nop_();\n    rst1302 = 0;\n    return(rcvdat);\n}\n\nvoid init_ds1302(void)\n{\n    rst1302 = 0;\n    sclk = 0;\n    ds1302_send_byte(0x8e, 0x00); /* 允许写命令 */\n    ds1302_send_byte(0x90, 0xaa); /* 涓流慢速充电 */\n    //ds1302_send_byte(0x80, 0x00); /* 时钟启动，开机时都要置0，以准确走时 */\n}\n\nvoid scan_keypad(void)\n{\n    uchar data tmp_num;\n    flag_key = 0;\n    if(tmp_shift_key == 0)\n    {\n        //delay_xms(5);\n        P3 = P3 & 0x3f;\n        P3 = P3 | 0x40;\n        tmp_num = P2;\n        while(tmp_num != 0x00)\n        {\n            delay_xms(5);\n            flag_jiami = 1;\n            switch(tmp_num)\n            {\n            case 0x01:\n                key_num = Cancel;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x02:\n                key_num = Serial_num;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x04:\n                key_num = Secret_code;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x08:\n                key_num = Lock;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x10:\n                key_num = Unlock;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x20:\n                key_num = 0;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x40:\n                key_num = Enter;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x80:\n                key_num = 1;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            default:\n                key_num = 0x00;\n                flag_key = 0;\n                break;\n            }\n            while(tmp_num != 0x00)\n            {\n                tmp_num = P2;\n            }\n        }\n        //delay_xms(5);\n        P3 = P3 & 0x3f;\n        P3 = P3 | 0x80;\n        tmp_num = P2;\n        while(tmp_num != 0x00)\n        {\n            delay_xms(5);\n            flag_jiami = 1;\n            switch(tmp_num)\n            {\n            case 0x01:\n                key_num = 2;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x02:\n                key_num = 3;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x04:\n                key_num = 4;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x08:\n                key_num = 5;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x10:\n                key_num = 6;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x20:\n                key_num = 7;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x40:\n                key_num = 8;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            case 0x80:\n                key_num = 9;\n                flag_key = 1;\n                flag_digital = 1;\n                break;\n            //case 0x14:key_num=Rest;flag_key=1;flag_digital=1;break;\n            default:\n                key_num = 0x00;\n                flag_key = 0;\n                break;\n            }\n            while(tmp_num != 0x00)\n            {\n                tmp_num = P2;\n            }\n        }\n        P3 = P3 & 0x3f;\n    }\n    if(tmp_shift_key == 1 && flag_jiami == 1)\n    {\n        key_num = Enter;\n        flag_key = 1;\n        //tmp_shift_key=1;   // shift键释放标志\n    }\n}\n\nvoid display(void)\n{\n    uchar data i, j;\n    for(i = 0; i < 6; i++)\n    {\n        j = digital_string[i];\n        P1 = display_code[j];\n        P0 = P0 | display_cs[i];\n        delay_xms(5);\n        P0 = P0 & 0xc0;\n    }\n}\n\n/*键盘输入*/\nvoid akey(uchar pp)\n{\n    uchar data i = 0;\n    uchar data temp, j;\n\n    do\n    {\n        display();          /* 动态显示 */\n        scan_keypad();      /* 动态扫描键盘 */\n        //if(ppp==1)\n        //digital_string[0]=14;\n\n        if(flag_key == 1)\n        {\n            flag_key = 0;\n            /*如果第一次按数字\\点则清显示以便输入*/\n            if(key_num < 0x0a && i < pp)\n            {\n                for(j = 1; j < pp; j++)\n                {\n                    /* 显示左移 */\n                    temp = digital_string[6 - pp + j];\n                    digital_string[5 - pp + j] = temp;\n\n                }\n                digital_string[5] = key_num;\n                i++;\n            }\n            else if(key_num == Cancel && i > 0)\n            {\n                for(j = 1; j < pp; j++)\n                {\n                    /* 显示右移 */\n                    temp = digital_string[5 - j];\n                    digital_string[6 - j] = temp;\n                }\n                digital_string[6 - pp] = 12; /* 空显示 */\n                i--;\n\n                if(i == 0) /* 等效于未按数字键 */\n                    flag_digital = 0;\n            }\n        }\n\n        if(key_num == Enter && tmp_shift_key == 1)\n            key_num = Enter;\n        else if(key_num == Enter && flag_digital == 0)\n            key_num = 0x00; /* 未按数字键而直接回车重新输数 */\n\n    }\n    while(key_num != Enter || i < pp); /* 回车结束数据输入 */\n}                               /* 且输入为位数正确为3位或6位 */\n\nvoid timer0() interrupt 1 using 3\n{\n    TMOD = 0x21;\n    TH0 = 0x4b;\n    TL0 = 0xff;\n    TR0 = 1; /*50ms定时*/\n    if(flag_all_unlock == 0)\n    {\n        counter_5m--;\n        if(counter_5m == 0)\n        {\n            flag_5m = 1;\n            counter_5m = 6000;\n        }\n    }\n}\n\nvoid series_int() interrupt 4 using 3\n{\n    /*上位机发的标志 “S”设定偏压（没用），“P”平衡键，“W”工作键*/\n    /*下位机发的标志“V”电解池偏压。“I”电解电流*/\n    uchar data i, j;\n    /*串行接收*/\n    if(RI == 1)\n    {\n        RI = 0;\n        if(SBUF == 'S')\n        {\n            /* 串口起始标志 */\n            for(i = 0; i < 6; i++)\n            {\n                /* 设置键 */\n                series_string[i] = 0x30;\n            }\n        }\n        /* 保存数字 */\n        else if(SBUF >= 0x30 && SBUF <= 0x39)\n        {\n            /* 调试密码 */\n            for(i = 0; i < 5; i++)\n            {\n                j = series_string[i + 1];\n                series_string[i] = j;\n            }\n            series_string[5] = SBUF;\n        }\n        /* 串口结束标志，A-F分别为加密密码、调试密码，G为设置调试密码 */\n        else if(SBUF >= 'A' && SBUF <= 'G') /* 回车键 */\n        {\n            flag_series = 1;\n            /*  SBUF='K';    回复联机成功信号K */\n        }\n        else if(SBUF == 'H' || SBUF == 'Y') /* 设置系统日期、时间*/\n            flag_series = 1;\n    }\n    else if(TI == 1)\n        TI = 0;\n}\n\nvoid get_ac_data(uchar z, int n)\n{\n    uchar data kk, pp;\n\n    kk = ds1302_receive_byte(z);\n    pp = kk >> 4;\n    digital_string[n] = pp + 0x30;\n    pp = kk & 0x0f;\n    digital_string[n + 1] = pp + 0x30;\n}\n\nvoid read_current_minute(void)\n{\n\n    /* 读当前时间 时 */\n    get_ac_data(0x85, 0);\n    /* 读当前时间 分 */\n    get_ac_data(0x83, 2);\n    /* 读当前时间 秒 */\n    get_ac_data(0x81, 4);\n}\n\nvoid read_current_date(void)\n{\n\n    /* 读当前时间 年 */\n    get_ac_data(0x8d, 0);\n    /* 读当前时间 月 */\n    get_ac_data(0x89, 2);\n    /* 读当前时间 日 */\n    get_ac_data(0x87, 4);\n\n    /*   kk=ds1302_receive_byte(0x81);\n       kk=ds1302_receive_byte(0x83);\n       kk=ds1302_receive_byte(0x85); */\n}\n\nuchar get_date(uchar z)\n{\n    uchar data year1, month1, date1;\n    date1 = ds1302_receive_byte(z);\n    year1 = (date1 >> 4) * 10;\n    date1 = ds1302_receive_byte(z);\n    date1 = date1 & 0x0f;\n    date1 = date1 + year1;\n    return date1;\n}\n\nvoid calculate_secutity_date(uchar i)\n{\n    uchar data new_yy;\n    uchar data new_mm;\n    uchar data new_dd;\n    uchar data month_day;\n\n    unsigned long data security_day;\n\n    uint code jiamitianshu[80] = {0, 1, 12, 18, 56, 44, 52, 10, 7, 23,\n                                  0, 42, 11, 24, 46, 54, 270, 4, 27, 37,\n                                  0, 48, 13, 999, 255, 300, 3, 16, 14, 90,\n                                  0, 22, 38, 285, 225, 240, 9, 20, 33, 180,\n                                  0, 34, 165, 15, 195, 135, 2, 25, 40, 36,\n                                  0, 19, 26, 150, 5, 21, 31, 17, 315, 28,\n                                  0, 60, 360, 8, 29, 35, 120, 50, 32, 210,\n                                  0, 6, 30, 39, 105, 75, 330\n                                 };\n\n\n    new_dd = get_date(0x87);\n\n    /* 读当前时间 月 */\n    new_mm = get_date(0x89);\n\n    /* 读当前时间 年 */\n    new_yy = get_date(0x8d);\n    /* 读该阶段的加密天数 */\n    security_day = jiamitianshu[i];\n    flag_warn_yymmdd = 0;\n    flag_over = 0;\n\n    do\n    {\n        if(new_mm > 12)\n        {\n            new_mm = new_mm - 12;\n            new_yy = new_yy + 1;\n        }\n\n        if(new_mm == 2 && new_mm <= 12)\n        {\n            if((2000 + new_yy) % 4 == 0 && (2000 + new_yy) % 100 != 0 || (2000 + new_yy) % 400 == 0)\n            {\n                month_day = 29;\n                yun = 1;\n            }\n            else\n            {\n                month_day = 28;\n                yun = 0;\n            }\n        }\n        else if(new_mm <= 12)\n            month_day = monthp[new_mm - 1];\n\n        if(security_day > 30)\n        {\n            if(month_day == 31)\n                security_day = security_day - 31;\n            else if(month_day == 30)\n                security_day = security_day - 30;\n            else if(month_day == 29)\n                security_day = security_day - 29;\n            else if(month_day == 28)\n                security_day = security_day - 28;\n            new_mm = new_mm + 1;\n\n            if(flag_warn_yymmdd == 1)\n                break;\n        }\n        else\n        {\n            if(security_day == 30)\n            {\n                if(month_day == 30)\n                {\n                    security_day = security_day - 30;\n                    new_mm = new_mm + 1;\n                }\n                else if(month_day == 29)\n                {\n                    security_day = security_day - 29;\n                    new_mm = new_mm + 1;\n                }\n                else if(month_day == 28)\n                {\n                    security_day = security_day - 28;\n                    new_mm = new_mm + 1;\n                }\n            }\n            else if(security_day == 29)\n            {\n                if(month_day == 29)\n                {\n                    security_day = security_day - 29;\n                    new_mm = new_mm + 1;\n                }\n                else if(month_day == 28)\n                {\n                    security_day = security_day - 28;\n                    new_mm = new_mm + 1;\n                }\n            }\n            else if(security_day == 28)\n            {\n                if(month_day == 28)\n                {\n                    security_day = security_day - 28;\n                    new_mm = new_mm + 1;\n                }\n            }\n\n            if(flag_warn_yymmdd == 0)\n            {\n                flag_warn_yymmdd = 1;\n                security_day = security_day + new_dd;\n            }\n            else\n                break;\n        }\n    }\n    while(1);\n\n    flag_warn_yymmdd = 0;\n    flag_over = 0;\n    if(new_mm > 12)\n    {\n        new_mm = new_mm - 12;\n        new_yy = new_yy + 1;\n    }\n    else if(new_mm == 2)\n    {\n        if((2000 + new_yy) % 4 == 0 && (2000 + new_yy) % 100 != 0 || (2000 + new_yy) % 400 == 0)\n            month_day = 29;\n        else\n            month_day = 28;\n\n        if(security_day > 28)\n        {\n            if(month_day == 28)\n            {\n                security_day = security_day - 28;\n                new_mm = new_mm + 1;\n            }\n            else if(month_day == 29)\n            {\n                security_day = security_day - 29;\n                new_mm = new_mm + 1;\n            }\n        }\n    }\n\n    digital_string[0] = new_yy / 10 + 0x30;\n    digital_string[1] = new_yy % 10 + 0x30;  /* 保存加密年ASCII */\n    digital_string[2] = new_mm / 10 + 0x30;\n    digital_string[3] = new_mm % 10 + 0x30;  /* 保存加密月ASCII */\n    digital_string[4] = security_day / 10 + 0x30;\n    digital_string[5] = security_day % 10 + 0x30; /* 保存加密日ASCII */\n\n    security_day = jiamitianshu[i];\n    if(security_day == 999) /* 如为999天，则写入永久密码680815 */\n    {\n        write_inte_to_eeprom(devicead_wd, 07, 60815); /*4*6*/\n        flag_all_unlock = 1;\n    }\n}\nuint yeardays(uchar month, uchar year)\n{\n    uchar mm;\n    uint ssa;\n    ssa = 0;\n    for(mm = 0; mm < (month - 1); mm++)\n    {\n        if((2000 + year) % 4 == 0 && (2000 + year) % 100 != 0 || (2000 + year) % 400 == 0)\n            ssa = ssa + monthy[mm];\n        else\n            ssa = ssa + monthp[mm];\n    }\n    return ssa;\n}\n\nvoid calculate_date_inter(void)\n{\n    uchar data kk;\n    uint data sum;\n    uchar data year1, month1, date1;\n    uchar data year2, month2, date2;\n    unsigned long data security_date;\n\n    date1 = get_date(0x87);\n\n    month1 = get_date(0x89);\n\n    year1 = get_date(0x8d);\n\n    security_date = read_flt_from_eeprom(devicead_wd, 00);\n\n    if(year1 * 10000 + month1 * 100 + date1 > security_date){\n        digital_string[0] = 12;\n        digital_string[1] = 12;\n        digital_string[2] = 12;\n        digital_string[3] = 0;\n        digital_string[4] = 0;\n        digital_string[5] = 0;\n        return;\n    }\n\n    year2 = security_date / 10000;\n\n    security_date = security_date % 10000;\n    month2 = security_date / 100;\n\n    security_date = security_date % 100;\n    date2 = security_date;\n\n    security_date = 0;\n    //sum=0;\n    if(year2 > year1)\n    {\n        for(kk = year1; kk < year2; kk++)\n        {\n            if((2000 + kk) % 4 == 0 && (2000 + kk) % 100 != 0 || (2000 + kk) % 400 == 0)\n                security_date = security_date + 366;\n            else\n                security_date = security_date + 365;\n        }\n    }\n    sum = yeardays(month2, year2);\n\n    security_date = security_date + sum + date2;\n    //sum=0;\n    sum = yeardays(month1, year1);\n    sum = sum + date1;\n    security_date = security_date - sum;\n\n    security_date = security_date % 1000;\n    for(kk = 0; kk < 6; kk++)\n        digital_string[kk] = 12;\n\n    digital_string[3] = security_date / 100;\n    security_date = security_date % 100;\n    digital_string[4] = security_date / 10;\n    digital_string[5] = security_date % 10;\n}\n\nvoid init_main(void)\n{\n    uchar i;\n    for( i = 0; i < 20; i++)\n        delay_xms(200);\n\n    PCON = 0x00;\n    SCON = 0x50;\n    TMOD = 0x21;\n    TH1 = 0xfd;\n    TL1 = 0xfd;\n    TR1 = 1;    /* BAUT=9600 */\n    TH0 = 0x4b;\n    TL0 = 0xff;\n    TR0 = 1;    /* 50ms定时 */\n    ET0 = 1;\n    ET1 = 0;\n    EX0 = 0;\n    EX1 = 0;\n    ES = 1; /* 允许定时器0、串口中断*/\n    IT0 = 1;\n    IT1 = 1;\n    counter_5m = 6000;            /* 5分钟计时初始化 */\n\n    //COM8255=0x92;                 /* A口、B口输入，C口输出 */\n    //PC8255=0x00;                  /* 开机锁定机床 */\n    //tmp_lock=1;\n}\n\nvoid send_ds1302(int n, uchar z)\n{\n    uchar data kk, pp;\n    kk = series_string[n] - 0x30;\n    kk = kk << 4;\n    pp = series_string[n + 1] - 0x30;\n    kk = kk + pp;\n    ds1302_send_byte(z, kk);\n}\nvoid resend_byte(uchar z, unsigned long xxx)\n{\n    uchar data  yyy, pp;\n    pp = xxx % 10;\n    yyy = xxx / 10;\n    yyy = yyy << 4;\n    yyy = yyy + pp;\n    ds1302_send_byte(z, yyy);\n}\nvoid resend_time(int kk)\n{\n    unsigned long data ddd, mmm;\n    ddd = read_flt_from_eeprom(devicead_wd, 20 + kk * 4); /////读取日期\n    //ddd=12;\n    mmm = ddd % 100;\n    resend_byte(0x86, mmm);  // BCD 日\n    mmm = ddd / 100;\n    mmm = mmm % 100;\n    resend_byte(0x88, mmm); // BCD 月\n    mmm = ddd / 10000;\n    mmm = mmm % 100;\n    resend_byte(0x8c, mmm); /////年\n    ddd = read_flt_from_eeprom(devicead_wd, 40 + kk * 4); /////读取时间\n    resend_byte(0x80, 0);  // BCD 秒\n    mmm = ddd / 100;\n    mmm = mmm % 100;\n    resend_byte(0x82, mmm); // BCD 分\n    mmm = ddd / 10000;\n    mmm = mmm % 100;\n    resend_byte(0x84, mmm); /////时\n}\nvoid displaydays(int ww, int n)\n{\n    digital_string[n] = ww;\n    series_string[n] = ww;\n    syts_string[n] = ww;\n}\nvoid displaytmp(int ww, int n)\n{\n    P1 = display_code[ww];\n    P0 = P0 | display_cs[n];\n    delay_xms(5);\n    P0 = P0 & 0xc0;\n}\nvoid outlocktmp(void)\n{\n    uchar data mm;\n    flag_pass = 0;\n    tmp_lock = 1;\n    /*   in_out_lock();     锁定 */\n    for(mm = 0; mm < 6; mm++)\n        digital_string[mm] = 13;\n    /*   SBUF='O';    回复超时信号O */\n    write_inte_to_eeprom(devicead_wd, 07, 0); /* 写入解密结束密码为0 */\n    write_chr_to_eeprom(devicead_wd, 05, 00); /* 请初次进入该阶段 */\n}\n\nmain()\n{\n    uchar idata kk, pp, i;\n    unsigned int idata ww;\n    //unsigned long data hh;\n    unsigned long int data security_final;\n    unsigned long int data security_current;\n    unsigned long int data security_current_buffer;\n    unsigned int sss;\n    unsigned int idata Ahourtime;\n    Ahourtime = 0;\n    sss = 0;\n    init_main();      /*  主程序初始化 */\n    init_ds1302();    /*  初始化DS1302 */\n    tmp_lock = 1;     /*  开机锁定 */\n\n\n    security_current = read_inte_from_eeprom(devicead_wd, 07); /* 4*6*/\n    security_current_buffer = 0xfffff;\n    flag_5m = 1;\n    flag_unlock = 1;   /* 解密标志 */\n    flag_all_unlock = 0;\n    EA = 1;\n    if( security_current != 60815)\n    {\n\n        read_current_date();\n        security_current = atol(digital_string);\n\n        if( (security_current > 500101) || (security_current < 71010) )\n            flag_5m = 1;\n        read_current_minute();\n        security_current_buffer = atol(digital_string);\n\n        for( i = 0; i < 50; i++)\n            delay_xms(200);\n        read_current_minute();\n        security_current = atol(digital_string);\n        if(security_current == security_current_buffer)\n            sss++;\n    }\n\n\n    /* 2008/04/07添加，以防止晶振不起振, 读当前时分秒 */\n    security_current = read_inte_from_eeprom(devicead_wd, 07);\n    security_current_buffer = 0xfffff;\n\n\n    do\n    {\n        if(flag_series == 1)\n        {\n            flag_series = 0;\n            if(SBUF == 'G') /*SBUF=='G' */\n            {\n                /* 如为调试识别码 */\n                /* security_final=atol(series_string);   写调试密码 */\n                /* write_inte_to_eeprom(devicead_ws,10,security_final);  4*5*/\n                /* for(kk=0;kk<21;kk++)   清5段加密标志、调试标志6 */\n                /*   write_chr_to_eeprom(devicead_wd,0x60+00,0x00);   0x20*/\n\n                /* 调试天数初值为99天 */\n                /* write_flt_to_eeprom(devicead_wd,4*20,99); 4*5*/\n                /* write_flt_to_eeprom(devicead_wd,4*21,0);  清最终解密密码4*6 */\n                /* write_flt_to_eeprom(devicead_ws,4*22,0);清失效密码4*7 */\n\n\n                /* for(kk=0;kk<20;kk++)\n                 {\n                    write_flt_to_eeprom(devicead_wd,4*kk,0);\n                    write_flt_to_eeprom(devicead_ws,4*kk,0xfffff);\n                 }*/\n                /* 如为调试识别码 */\n                security_final = atol(series_string); /* 写识别密码 */\n                write_inte_to_eeprom(devicead_wd, 10, security_final); /*  4*5*/\n                write_chr_to_eeprom(devicead_wd, 05, 0); /* 阶段标志 */\n                write_chr_to_eeprom(devicead_wd, 06, 0); /* 随机码地址 */\n                write_inte_to_eeprom(devicead_wd, 07, 0); /* 初始化解密密码 */\n                write_inte_to_eeprom(devicead_wm, 03, 1234); /*初始化密码*/\n                for(kk = 0; kk < 128; kk++)\n                    write_inte_to_eeprom(devicead_ws, 2 * kk, 0); /* 清随机码 */\n            }\n            else if(SBUF == 'Y')  /*SBUF=='Y'*/\n            {\n                /* 串口设置日期 yy-mm-dd */\n                /*    init_ds1302();     初始化DS1302 */\n\n                send_ds1302(4, 0x86);\n                send_ds1302(2, 0x88);\n                send_ds1302(0, 0x8c);\n                read_current_date(); //////保存当前日期\n                security_current = atol(digital_string);\n                write_flt_to_eeprom(devicead_wd, 20, security_current);\n                write_flt_to_eeprom(devicead_wd, 24, 0);\n                write_flt_to_eeprom(devicead_wd, 30, 0);\n                write_inte_to_eeprom(devicead_wd, 34, 0);\n            }\n            else if(SBUF == 'H') /*SBUF=='H' */\n            {\n                /* 串口设置时间hh-mm-ss */\n                /*     init_ds1302();    初始化DS1302 */\n                send_ds1302(2, 0x82);\n                send_ds1302(0, 0x84);\n                read_current_minute(); //////保存当前时间\n                security_current = atol(digital_string);\n                write_flt_to_eeprom(devicead_wd, 40, security_current);\n                write_flt_to_eeprom(devicead_wd, 44, 0);\n                write_flt_to_eeprom(devicead_wd, 50, 0);\n            }\n        }\n\n        else if(flag_unlock == 1)\n        {\n            flag_unlock = 0;\n            flag_pass = 0;\n\n            if(security_current == 60815)\n            {\n                flag_all_unlock = 1;\n                tmp_lock = 0;\n                //PC8255=0x80;\n                /*  in_out_unlock();    解锁 */\n                /*  display_init1(); */\n                for(kk = 0; kk < 6; kk++)\n                    digital_string[kk] = 0x08;\n                /*   while(1);          如为最终解密码，则不在往下走*/\n            }\n            else if(security_current == 20926) /* 正常解密成功 */\n            {\n                tmp_lock = 0; /////\n                /* 从PAGE1的00X20-0X24读是否是初次进入该密码阶段 */\n                kk = read_chr_from_eeprom(devicead_wd, 05); /*0x20*/\n                if(kk != 0xcc)\n                {\n                    /* 初次进入，写入已进入该阶段标志0XCC */\n                    write_chr_to_eeprom(devicead_wd, 05, 0xcc); /*0x20*/\n\n                    /* 初次解密时计算最终加密日期 */\n                    /* i=series_string[0]*10+series_string[1];  加密天数密码*/\n                    /* i=i-10;   加密天数密码为10-99，故实际有90个加密阶段 */\n                    security_final = series_string[0] * 100 + series_string[1] * 10 + series_string[2];\n                    i = security_final / 13;\n                    calculate_secutity_date(i);\n                    security_final = atol(digital_string); /* 保存最后的加密结束日期*/\n                    write_flt_to_eeprom(devicead_wd, 00, security_final);\n                }\n                /*  display_init0(); 显示------，准备动态循环显示*/\n                for(kk = 0; kk < 6; kk++)\n                    digital_string[kk] = 10;\n\n                flag_pass = 1;  /* 解密成功 */\n                flag_5m = 1; /* 以便与立即比较是否过日期*/\n            }\n            else /*未能正常解密 */\n            {\n                /*随机码的产生原则：首先产生一个0-32768之间的随机数*/\n                /*然后将识别码*6，以保证两者相加不超过9999*/\n                /*两者相加产生5位随机码*/\n                /*如不加上识别码可能不同的机子会产生相同的随机码*/\n                do\n                {\n                    flag_error = 0;\n                    security_current = rand(); /*产生一个0-32768的随机数*/\n                    security_final = read_inte_from_eeprom(devicead_wd, 10); /*读识别码*/\n                    security_final = security_final * 3; /* 识别码最大为9999 */\n                    security_current = security_current + security_final;\n                    /* security_current最大不超过32768+3*9999，即不超过整数的范围65535，便于下面计算*/\n                    /* 以防止每次开机时产生同样的随机码*/\n                    /* 这样尽管rand()函数产生相同的数，但不同的机子有不同的识别码*/\n                    kk = read_chr_from_eeprom(devicead_wd, 0x06);\n                    kk = kk / 2;                    /* 随机码地址=随机码个数*2 */\n                    for(pp = 0; pp < kk; pp++)\n                    {\n                        /*读已存放的随机码*/\n                        security_final = read_inte_from_eeprom(devicead_ws, pp * 2);\n                        if(security_current == security_final)\n                        {\n                            flag_error = 1;\n                            break;\n                        }\n                    }\n                }while(flag_error == 1);\n\n                displaydays(0x00, 0);   /* 用于显示剩余天数时备用显示随机码 2004/04/10增加*/\n                kk = security_current / 10000;\n                displaydays(kk, 1);     /* 用于显示剩余天数时备用显示随机码 2004/04/10增加*/\n                kk = security_current / 1000;\n                pp = kk % 10;\n                displaydays(pp, 2);      /* 用于显示剩余天数时备用显示随机码 2004/04/10增加*/\n                security_final = security_current - kk * 1000;\n                kk = security_final / 100;\n                displaydays(kk, 3);      /* 用于显示剩余天数时备用显示随机码 2004/04/10增加*/\n                kk = security_final % 100;\n                pp = kk / 10;\n                displaydays(pp, 4);      /* 用于显示剩余天数时备用显示随机码 2004/04/10增加*/\n                pp = kk % 10;\n                displaydays(pp, 5);     /* 用于显示剩余天数时备用显示随机码 2004/04/10增加*/\n\n            }\n        }\n\n        else if(flag_key == 1 && tmp_shift_key == 0)\n        {\n            flag_key = 0;\n            /*-------------------------------------------------------*/\n            if(key_num == Serial_num)   //显示序列号\n            {\n                //read_inte_from_eeprom(devicead_wd,10);\n                do\n                {\n\n                    scan_keypad();\n\n                    ww = 13;\n                    displaytmp(ww, 0);\n\n                    ww = 13;\n                    displaytmp(ww, 1);\n\n\n                    ww = read_inte_from_eeprom(devicead_wd, 10);\n                    ww = ww / 1000;\n                    displaytmp(ww, 2);\n                    ww = read_inte_from_eeprom(devicead_wd, 10);\n                    ww = (ww / 100) % 10;\n                    displaytmp(ww, 3);\n\n                    ww = read_inte_from_eeprom(devicead_wd, 10);\n                    ww = (ww % 100) / 10;\n                    displaytmp(ww, 4);\n                    ww = read_inte_from_eeprom(devicead_wd, 10);\n                    ww = ww % 10;\n                    displaytmp(ww, 5);\n\n                }\n                while(tmp_shift_key == 0);\n                flag_key = 0;\n                flag_jiami = 0;\n                key_num = 0;\n\n            }\n            /*if(key_num==4)\n            {\n              //read_inte_from_eeprom(devicead_wd,10);\n               do\n               {\n\n               scan_keypad();\n\n               ww=10;\n               displaytmp(ww,0);\n\n               ww=10;\n               displaytmp(ww,1);\n\n\n               ww=read_inte_from_eeprom(devicead_wm,3);\n               ww=ww/1000;\n               displaytmp(ww,2);\n               ww=read_inte_from_eeprom(devicead_wm,3);\n               ww=(ww/100)%10;\n               displaytmp(ww,3);\n\n               ww=read_inte_from_eeprom(devicead_wm,3);\n               ww=(ww%100)/10;\n               displaytmp(ww,4);\n               ww=read_inte_from_eeprom(devicead_wm,3);\n               ww=ww%10;\n               displaytmp(ww,5);\n\n               }while(tmp_shift_key==0);\n               flag_key=0;\n               flag_jiami=0;\n               key_num=0;\n\n            }*/\n\n            else if(key_num == Secret_code)\n            {\n                flag_key = 0x00;\n                key_num = 0x00;  // 清键值\n\n                // 是否是串口解密，如为串口解密则跳出键盘输入\n                if(flag_series_unlock == 0)\n                {\n                    for(kk = 0; kk < 6; kk++)\n                        digital_string[kk] = 12; //清空显示单元，准备显示解密密码\n\n                    //akey(5,1);\n                    akey(6);\n                    flag_digital = 0;\n                }\n                key_num = 0x00;  /* 清键值 */\n                flag_key = 0x00;\n\n                /* 是否是串口解密，如为串口解密则跳出字符转换 */\n                if (flag_series_unlock == 0)\n                {\n                    for(kk = 0; kk < 6; kk++)\n\n                    {\n                        if(digital_string[kk] == 0x0c)\n                            digital_string[kk] = 0x30; /* 空格处理 */\n                        else\n                            digital_string[kk] = digital_string[kk] + 0x30;\n                    }\n                }\n                else\n                    flag_series_unlock = 0;\n\n                if(flag_shift == 0)\n                {\n                    pp = (digital_string[0] - 0x30) * 10 + digital_string[1] - 0x30;\n                    kk = pp / 7;\n                    pp = pp % 7;\n                    if((digital_string[1] - 0x30) > 6)\n                        security_current = (digital_string[2] - 0x30) * 1000 + (digital_string[3] - 0x30) * 100 + (digital_string[4] - 0x30) * 10 + (digital_string[5] - 0x30);\n                    else\n                        security_current = (digital_string[1] - 0x30) * 10000 + (digital_string[2] - 0x30) * 1000 + (digital_string[3] - 0x30) * 100 + (digital_string[4] - 0x30) * 10 + (digital_string[5] - 0x30);\n                    security_final = read_inte_from_eeprom(devicead_wm, 03);\n                    ww = read_inte_from_eeprom(devicead_wd, 10);\n                    //write_inte_to_eeprom(devicead_wm,03,security_current);\n\n\n                    if(pp == 6 && kk == (digital_string[5] - 0x30))\n                    {\n                        pp = 0;\n                        kk = 0;\n                        security_current_buffer = ww * 3;\n                        security_current_buffer = security_current_buffer + 17351;\n                        security_current_buffer = security_current_buffer % 10000;\n                        security_current = security_current % 10000;\n                        if(security_current == security_current_buffer)\n                        {\n                            write_inte_to_eeprom(devicead_wm, 03, 1234);\n                        }\n                    }\n                    else if((digital_string[0] - 0x30) == 0)\n                    {\n                        if(security_current < 60000)\n                        {\n                            //pp=0;\n                            security_final = security_final * 2;\n                            security_current = security_current - ww;\n                            security_current = security_current - security_final;\n                            kk = security_current % 3;\n\n                            if(kk == 0)\n                            {\n                                security_current = security_current / 3;\n                                if(security_current < 10000)\n                                {\n                                    write_inte_to_eeprom(devicead_wm, 03, security_current);\n                                    for(kk = 0; kk < 6; kk++)\n                                        digital_string[kk] = 6;\n                                }\n                            }\n                        }\n                    }\n                }else//添加\n                {\n                    flag_key = 0;\n                    flag_shift = 0;\n                    flag_jiami = 0;\n                    key_num = 0x00;\n                    for(kk = 0; kk < 6; kk++)\n                        digital_string[kk] = 10; // 显示------\n                }\n            }\n            else if(key_num == Lock)\n            {\n                calculate_date_inter();\n                security_current = read_inte_from_eeprom(devicead_wd, 07);\n                if(security_current == 60815)\n                {\n                    digital_string[3] = 9;\n                    digital_string[4] = 9;\n                    digital_string[5] = 9;\n                }\n                do\n                {\n                    display();\n                    scan_keypad();\n                }\n                while(tmp_shift_key == 0);\n\n                flag_key = 0;\n                flag_jiami = 0;\n                key_num = 0x00;\n\n                for(kk = 0; kk < 6; kk++)\n                {\n                    pp = syts_string[kk];   //用于显示剩余天数时备用显示随机码 2004/04/10增加\n                    digital_string[kk] = pp; // 不进行转换的化将看不到随机码，否则显示永远剩余加密天数\n                }\n            }/*2008/04/10*/\n\n            //-------------------------------------------------------*\n\n            else if(key_num == Unlock)\n            {\n                flag_key = 0x00;\n                key_num = 0x00;  // 清键值\n\n                // 是否是串口解密，如为串口解密则跳出键盘输入\n                if(flag_series_unlock == 0)\n                {\n                    for(kk = 0; kk < 6; kk++)\n                        digital_string[kk] = 12; // 清空显示单元，准备显示解密密码\n\n                    akey(6);\n                    flag_digital = 0;\n                }\n                key_num = 0x00;  // 清键值\n                flag_key = 0x00;\n\n                // 是否是串口解密，如为串口解密则跳出字符转换\n                if (flag_series_unlock == 0)\n                {\n                    for(kk = 0; kk < 6; kk++)\n                    {\n                        if(digital_string[kk] == 0x0c)\n                            digital_string[kk] = 0x30; //空格处理\n                        else\n                            digital_string[kk] = digital_string[kk] + 0x30;\n                    }\n                }\n                else\n                    flag_series_unlock = 0;\n\n                if(tmp_shift_key == 0)\n                {\n                    //解密思路/\n                    //设从键盘输入的六位解密密码为ABCDEF,随机产生的随机数为abcdef/\n                    //按下述解密公式计算b*b*b*b*b+123*c*c*c*c*c+367*d*d*d+743*e*e+986*f+1534/\n                    //取上述计算值的低四位与BCDE进行比较，如相等则写入920926，否则写入0\n                    kk = series_string[1];\n                    security_final = kk * kk;\n                    security_final = security_final * kk;\n                    security_final = security_final * kk;\n                    security_final = security_final * kk; // b*b*b*b*b\n\n                    kk = series_string[2];\n                    security_current = kk * kk;\n                    security_current = security_current * kk;\n                    security_current = security_current * kk;\n                    security_current = security_current * 152; // 123*c*c*c*c*c\n                    security_current = security_current + security_final;\n\n                    kk = series_string[3];\n                    security_final = kk * kk;\n                    security_final = security_final * kk;\n                    security_final = 332 * security_final; // 367*d*d*d\n                    security_current = security_current + security_final;\n\n                    kk = series_string[4];\n                    security_final = kk * kk;\n                    security_final = 622 * security_final; // 743*e*e /\n                    security_current = security_current + security_final;\n\n                    kk = series_string[5];\n                    security_final = 832 * kk;            // 986*f /\n\n                    // security_final=security_final+1571;   // 1534 /\n\n                    security_current = security_current + security_final;\n                    // security_final=security_current%10000; 取计算结果的低4位 /\n                    // security_final=security_final*10;   乘以10以与digital_string的格式一致 //\n\n\n\n                    security_final = read_inte_from_eeprom(devicead_wd, 10); //读识别码/\n                    //security_final=security_final*153;\n                    //security_current=security_current+security_final;/\n                    // security_final=security_current%10000; 取计算结果的低4位 //\n                    // security_final=security_final*10;   乘以10以与digital_string的格式一致 //\n                    //security_final=read_inte_from_eeprom(devicead_wd,10); //读识别码/\n                    //security_final=security_final*332;\n                    //security_current=security_current+security_final;\n                    ww = read_inte_from_eeprom(devicead_wm, 03);\n                    security_final = security_final * 153;\n                    ww = ww + 1732;\n                    security_current = security_current + security_final + ww;\n                    security_final = security_current % 1000;\n\n                    for(kk = 0; kk < 6; kk++)\n                    {\n                        pp = series_string[kk];\n                        pp = pp + 0x30;\n                        series_string[kk] = pp; // 转换成字符数便于下面保存随机码//\n                    }\n\n\n                    security_current = (digital_string[0] - 0x30) * 100 + (digital_string[2] - 0x30) * 10 + digital_string[4] - 0x30;\n                    kk = security_current % 13;\n                    if(kk == 0)\n                    {\n                        security_current = (digital_string[1] - 0x30) * 100 + (digital_string[3] - 0x30) * 10 + digital_string[5] - 0x30;\n                        if(security_current == security_final) // 与计算的解密密码相比较/\n                        {\n                            write_inte_to_eeprom(devicead_wd, 07, 20926); //写入解密成功密码20926/\n                            kk = read_chr_from_eeprom(devicead_wd, 06); //读随机码存放地址/\n                            security_current = atol(series_string);    //保存该次解密成功的随机码/\n                            write_inte_to_eeprom(devicead_ws, kk, security_current);\n                            series_string[0] = digital_string[0] - 0x30;\n                            series_string[1] = digital_string[2] - 0x30;\n                            series_string[2] = digital_string[4] - 0x30;\n                            //\n                            kk = kk + 2;                               //地址加2/\n                            // 因kk为字符型，256自动为0 //\n                            //   if(kk==256)           如0区已存放满，则从头开始重新存放\n                            // kk=0x00;//\n\n                            flag_pass = 1;  // 解密成功 /\n                            flag_5m = 1; // 以便与立即比较是否过日期/\n\n                            write_chr_to_eeprom(devicead_wd, 06, kk); //保存随机码个数或地址/\n                            flag_unlock = 1; // 置解密标志，回到else if(flag_unlock==1)判别密码相等 //\n                            security_current = read_inte_from_eeprom(devicead_wd, 07);\n                        }              // 读当前解密密码，回到else if(flag_unlock==1)判别密码相等 //\n                        else\n                        {\n                            write_flt_to_eeprom(devicead_wd, 00, 0);\n                            write_inte_to_eeprom(devicead_wd, 07, 0); //写入解密失效密码0//\n\n                            //080313补，否则下次时间不好修改//\n                            write_chr_to_eeprom(devicead_wd, 05, 00); // 请初次进入该阶段 //\n                            while(1){\n                                digital_string[0] = 12;\n                                digital_string[1] = 12;\n                                digital_string[2] = 12;\n                                digital_string[3] = 12;\n                                digital_string[4] = 15;\n                                digital_string[5] = 15;\n                            }                            \n                        }\n                        // flag_unlock=1;   置解密标志，回到else if(flag_unlock==1)判别密码相等 //\n                    } else {\n                        write_flt_to_eeprom(devicead_wd, 00, 0);\n                        write_inte_to_eeprom(devicead_wd, 07, 0); //写入解密失效密码0//\n                        write_chr_to_eeprom(devicead_wd, 05, 00); // 请初次进入该阶段 //\n                        while(1){\n                            digital_string[0] = 12;\n                            digital_string[1] = 12;\n                            digital_string[2] = 12;\n                            digital_string[3] = 12;\n                            digital_string[4] = 15;\n                            digital_string[5] = 15;\n                        }\n                    }\n                } else {                    \n                    flag_key = 0;\n                    flag_jiami = 0;\n                    key_num = 0x00;\n                    for(kk = 0; kk < 6; kk++)\n                        digital_string[kk] = 10; // 显示------ /                    \n                }\n            }\n            else if(key_num == Enter) /* 退出shift键时的处理 */\n            {\n                key_num = 0x00;\n                flag_key = 0;\n                flag_jiami = 0;\n            }\n        }\n\n        else if(flag_5m == 1)\n        {\n            flag_5m = 0;\n            Ahourtime++;\n            if(Ahourtime > 5)\n            {\n                Ahourtime = 0;\n                /////保存当前时间和日期\n                kk = read_inte_from_eeprom(devicead_wd, 34);\n                kk++;\n                if(kk > 2)\n                    kk = 0;\n                //kk=1;\n                read_current_date(); //////保存当前日期\n                security_current = atol(digital_string);\n                write_flt_to_eeprom(devicead_wd, 20 + kk * 4, security_current);\n                read_current_minute(); //////保存当前时间\n                security_current = atol(digital_string);\n                write_flt_to_eeprom(devicead_wd, 40 + kk * 4, security_current);\n                write_inte_to_eeprom(devicead_wd, 34, kk);\n\n            }\n\n            read_current_date();\n            security_current = atol(digital_string);\n            /*term　保存有效密码阶段，以防误动作时读加密时间有误　*/\n            security_final = read_flt_from_eeprom(devicead_wd, 00); /*读最后的使用日期*/\n\n            if(flag_all_unlock == 1)\n            {\n                TR0 = 1;\n                flag_pass = 1;\n                /*  display_init1(); */\n                for(kk = 0; kk < 6; kk++)\n                    digital_string[kk] = 0x08;\n                /* in_out_unlock();    解锁 */\n                //PC8255=0x80;\n                tmp_lock = 0;\n                //flag_error=1;\n            }\n            else if(security_current < 71010)\n            {\n                /* 防止用户短电池 */\n                TR0 = 0;\n\n                kk = read_inte_from_eeprom(devicead_wd, 34);\n                resend_time(kk);\n            }\n\n            else if(security_final > security_current)\n            {\n                int ddd;\n\n                int bbb = security_current % 100;\n                security_current = security_final - security_current;\n\n\n\n                if(security_current > 30 && security_current < 131)\n                {\n                    int aaa = (security_current / 100) % 100;\n                    if(yun == 1)\n                        ddd = monthy[aaa - 1];\n                    else\n                        ddd = monthp[aaa - 1];\n                    security_current = security_final % 100 + ddd - bbb;\n                }\n                if(security_current > 6)\n                {\n                    valid_day[0] = 0x00;\n                    valid_day[1] = 0x00;\n                }\n                else\n                {\n                    valid_day[0] = display_code[0];\n                    valid_day[1] = display_code[security_current];\n                }\n\n\n\n                /* 2008/04/07添加，以防止晶振不起振, 读当前时分秒 */\n                read_current_minute();\n                security_current = atol(digital_string);\n                if(security_current == security_current_buffer)\n                {\n                    TR0 = 0;\n                    if(sss == 4)\n                    {\n                        ///初始化时间和日期\n                        kk = read_inte_from_eeprom(devicead_wd, 34);\n                        resend_time(kk);\n                    }\n                    if(sss > 7)\n                    {\n\n                        outlocktmp();\n                        valid_day[0] = 0x40;\n                        valid_day[1] = 0x40;\n                    }\n                    else\n                        sss++;\n                }\n                else\n                {\n                    TR0 = 1;\n                    flag_pass = 1;\n                    /*  in_out_unlock();   解锁 */\n                    tmp_lock = 0;\n                    security_current_buffer = security_current;\n                }\n            }\n            else\n            {\n                TR0 = 0;\n                outlocktmp();\n\n\n                valid_day[0] = 0x40;\n                valid_day[1] = 0x40;\n            }\n        }\n\n        else\n        {\n            if(tmp_shift_key == 1)\n            {\n                delay_xms(5);\n                P3 = P3 & 0x3f;\n                P3 = P3 | 0x40;\n\n                kk = P2;\n                kk = kk >> 4;\n                displaytmp(kk, 0);\n\n                kk = P2;\n                kk = kk & 0x0f;\n                displaytmp(kk, 1);\n\n                P3 = P3 & 0x3f;\n                P3 = P3 | 0x80;\n\n                kk = P2;\n                kk = kk >> 4;\n                displaytmp(kk, 2);\n\n                kk = P2;\n                kk = kk & 0x0f;\n                displaytmp(kk, 3);\n                P3 = P3 & 0x3f;\n\n\n\n                // 以下为补充加入的闪烁显示小于5天\n                flash_valid_day++;\n                if(flash_valid_day < 90)\n                {\n                    P1 = valid_day[0];\n                    P0 = P0 | display_cs[4];\n                    delay_xms(5);\n                    P0 = P0 & 0xc0;\n                    // 显示乘余天数\n\n                    P1 = valid_day[1];\n                    P0 = P0 | display_cs[5];\n                    delay_xms(5);\n                    P0 = P0 & 0xc0;\n\n\n                }\n                else if(flash_valid_day > 170)\n                    flash_valid_day = 0;\n                else\n                {\n                    P1 = 0x00;\n                    P0 = P0 | display_cs[4];\n                    delay_xms(5);\n                    P0 = P0 & 0xc0;\n\n                    P1 = 0x00;\n                    P0 = P0 | display_cs[5];\n                    delay_xms(5);\n                    P0 = P0 & 0xc0;\n                }\n            }\n            else  /* 显示 */\n            {\n                if(flag_pass == 1)\n                {\n                    /* 如解密成功则闪烁显示------ */\n                    if(flag_all_unlock == 0)\n                    {\n                        if(flag_flash == 0)\n                        {\n                            flag_flash = ~flag_flash;\n                            delay_xms(2000);\n                        }\n                        else\n                        {\n                            flag_flash = ~flag_flash;\n                            for(kk = 0; kk < 6; kk++)\n                                digital_string[kk] = 10;\n                            display();\n                        }\n                    }\n                    else\n                    {\n                        for(kk = 0; kk < 6; kk++)\n                            digital_string[kk] = 0x08;\n                        display();\n                    }\n                }\n                else\n                    display();   /* 如未解密成功则显示------ */\n            }\n        }\n\n        scan_keypad();      /*  扫描键盘 */\n    }\n    while(1);\n}\n",
			"file": "/D/workspace2/git/sytec/company/XiaMenDingYun/mcu/SYYGB.C",
			"file_size": 58927,
			"file_write_time": 131351399293849645,
			"settings":
			{
				"buffer_size": 55064,
				"line_ending": "Windows",
				"scratch": true
			}
		},
		{
			"file": "mcu-plc-fingure/mpf.h",
			"settings":
			{
				"buffer_size": 3188,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "mcu-plc-fingure/led.h",
			"settings":
			{
				"buffer_size": 500,
				"encoding": "UTF-8",
				"line_ending": "Windows",
				"name": "#in"
			}
		},
		{
			"file": "mcu-plc/mcu-plc.h",
			"settings":
			{
				"buffer_size": 946,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "mcu-plc-fingure/uart.h",
			"settings":
			{
				"buffer_size": 406,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "mcu-plc-fingure/fingure.h",
			"settings":
			{
				"buffer_size": 2035,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "mcu-plc-fingure/event.h",
			"settings":
			{
				"buffer_size": 1854,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "Packages/User/cpp2exe.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/C++/C++ Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					"Run"
				]
			],
			[
				"Packages/C++/C++ Single File.sublime-build",
				"Run"
			]
		],
		[
			[
				[
					"Packages/C++/C++ Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					"Run"
				],
				[
					"Packages/User/go.sublime-build",
					""
				],
				[
					"Packages/User/go.sublime-build",
					"Run"
				]
			],
			[
				"Packages/C++/C++ Single File.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/User/cpp2exe.sublime-build",
					""
				],
				[
					"Packages/User/cpp2exe.sublime-build",
					"Run"
				]
			],
			[
				"Packages/User/cpp2exe.sublime-build",
				"Run"
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 117.0,
		"last_filter": "quick",
		"selected_items":
		[
			[
				"quick",
				"CoolFormat: Quick Format"
			],
			[
				"men",
				"View: Toggle Menu"
			],
			[
				"open file",
				"View: Toggle Open Files in Side Bar"
			],
			[
				"openfi",
				"TodoReview: Open Files"
			],
			[
				"c",
				"Set Syntax: C"
			],
			[
				"mini",
				"View: Toggle Minimap"
			],
			[
				"stat",
				"View: Toggle Status Bar"
			],
			[
				"me",
				"View: Toggle Menu"
			],
			[
				"cq",
				"CoolFormat: Quick Format"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"istall",
				"Package Control: Install Package"
			],
			[
				"menu",
				"View: Toggle Menu"
			],
			[
				"tod",
				"TodoReview: Open Files"
			],
			[
				"LIST",
				"Package Control: List Packages"
			]
		],
		"width": 612.0
	},
	"console":
	{
		"height": 186.0,
		"history":
		[
			"git commit -m",
			"import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/D/workspace-npm/fingure"
	],
	"file_history":
	[
		"/D/workspace2/git/sytec/company/XiaMenDingYun/mcu/SYYGB.C",
		"/D/workspace2/git/sytec/company/XiaMenDingYun/mcu/SYYGB-bugfix.C",
		"/D/workspace2/git/sytec/company/XiaMenDingYun/SYYGB-bugfix.C",
		"/D/workspace2/Cpp/Qt/QtDemo/mainwindow.cpp",
		"/D/workspace2/Cpp/startrun/Win32Project1/Win32Project1.cpp",
		"/D/workspace-npm/fingure/go-backup/main.go",
		"/D/workspace-npm/fingure/.gitignore",
		"/D/workspace-npm/fingure/mcu-plc/mcu-plc.c",
		"/D/workspace-npm/fingure/mcu-plc/mcu-plc.h",
		"/D/workspace-npm/fingure/mcu/fingure.h",
		"/D/workspace-npm/fingure/mcu/event.h",
		"/D/workspace-npm/fingure/mcu/uart.h",
		"/D/workspace-npm/fingure/mcu/fingure.c",
		"/D/workspace-npm/fingure/mel-test/ruleTest.h",
		"/D/workspace-npm/fingure/mcu-plc-fingure/mpf.c",
		"/D/workspace-npm/fingure/input.js",
		"/D/workspace-npm/fingure/mcu/uart.c",
		"/D/workspace-npm/fingure/mel-test/ruleTest.cpp",
		"/C/Users/Administrator/AppData/Roaming/Sublime Text 3/Packages/User/cpp2exe.sublime-build",
		"/D/workspace-npm/fingure/mcu/blog.md",
		"/D/workspace-npm/fingure/README.MD",
		"/D/workspace/C/上海宇松/double_encrypt_10AM.c",
		"/C/Users/Administrator/Desktop/51_DHT21.c",
		"/C/Users/Administrator/AppData/Roaming/Sublime Text 3/Packages/Clang Format/Default (Windows).sublime-keymap",
		"/C/Users/Administrator/AppData/Roaming/Sublime Text 3/Packages/User/Terminal.sublime-settings",
		"/C/Users/Administrator/AppData/Roaming/Sublime Text 3/Packages/Terminal/Terminal.sublime-settings",
		"/C/Users/Administrator/AppData/Roaming/Sublime Text 3/Packages/User/Terminal (Windows).sublime-settings",
		"/C/Users/Administrator/AppData/Roaming/Sublime Text 3/Packages/Terminal/Default (Windows).sublime-keymap",
		"/D/workspace-npm/fingure/mcu/fingure",
		"/D/workspace2/git/sytec/company/ChangZhouYouRui/mcu/singleDecryptLockAt10AM.c",
		"/D/workspace2/git/sytec/company/ChangZhouYouRui/mcu/SYDEC.C"
	],
	"find":
	{
		"height": 67.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"outlocktmp",
			"10",
			"随机码",
			"syts_string",
			"devicead_wm, 03",
			"flag_unlock",
			"read_inte_from_eeprom",
			"flag_5m",
			"five",
			"showSucess",
			"SYMBOL",
			"LED",
			"sendCmdFunction",
			"r4times",
			"time36",
			"random_num4",
			"reBuildRandom",
			"r4times",
			"flag_ppor6",
			"delay_msec(10);",
			"writeX0",
			"readucharTemp",
			"y220",
			"P1",
			"checkInputSignal",
			"中断",
			"P1",
			"onReceivedAddressListEvent",
			"uartSendByte",
			"display",
			"sendCmdStatus",
			"checkInputSignal",
			"sendCmd",
			"sendCmd ",
			"uchar code",
			"waitTimes",
			"waitForReceiveFunction",
			"datByte",
			"sendCmdFunction",
			"中断",
			"checkInputSignal",
			"sendCmd",
			"PARAM1",
			"fiveMinuteFunction",
			"核心"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"delay(50);",
			"writePLCIOL4",
			"readPLCIOH4",
			"ucharTemp",
			"#define"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "mcu-plc-fingure/mpf.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18313,
						"regions":
						{
						},
						"selection":
						[
							[
								17487,
								17487
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "mcu-plc-fingure/led.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 736,
						"regions":
						{
						},
						"selection":
						[
							[
								144,
								124
							]
						],
						"settings":
						{
							"auto_name": "s",
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C++/C.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/D/workspace2/git/sytec/company/ChangZhouYouRui/20170322mcu/double_encrypt_12AM.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 34126,
						"regions":
						{
						},
						"selection":
						[
							[
								2012,
								2012
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C++/C.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 2473.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "mcu-plc-fingure/fingure.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3791,
						"regions":
						{
						},
						"selection":
						[
							[
								3451,
								3451
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5330.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "mcu-plc/mcu-plc.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3634,
						"regions":
						{
						},
						"selection":
						[
							[
								373,
								373
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 6929.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/D/workspace/Qt/SimensKeyboard/mainwindow.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1149,
						"regions":
						{
						},
						"selection":
						[
							[
								190,
								157
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8 with BOM",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/D/workspace2/git/sytec/company/XiaMenDingYun/mcu/SYYGB.C",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 55064,
						"regions":
						{
						},
						"selection":
						[
							[
								53865,
								53865
							]
						],
						"settings":
						{
							"in_converting": true,
							"is_init_dirty_state": false,
							"origin_encoding": "GB2312",
							"revert_to_scratch": true,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 75576.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 7,
					"file": "mcu-plc-fingure/mpf.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3188,
						"regions":
						{
						},
						"selection":
						[
							[
								290,
								277
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "mcu-plc-fingure/led.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 500,
						"regions":
						{
						},
						"selection":
						[
							[
								466,
								411
							]
						],
						"settings":
						{
							"auto_name": "#in",
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "mcu-plc/mcu-plc.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 946,
						"regions":
						{
						},
						"selection":
						[
							[
								808,
								808
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "mcu-plc-fingure/uart.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 406,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "mcu-plc-fingure/fingure.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2035,
						"regions":
						{
						},
						"selection":
						[
							[
								2026,
								2026
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 2829.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "mcu-plc-fingure/event.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1854,
						"regions":
						{
						},
						"selection":
						[
							[
								35,
								35
							]
						],
						"settings":
						{
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 123.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 49.0
	},
	"input":
	{
		"height": 67.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.452542879064,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 250.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "Packages/User/cpp2exe.sublime-build",
	"project": "fingure.sublime-project",
	"replace":
	{
		"height": 130.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 1,
	"settings":
	{
	},
	"show_minimap": false,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 259.0,
	"status_bar_visible": false,
	"template_settings":
	{
	}
}
